package test.collegecarpool.alpha.Services;

import android.app.Service;
import android.content.Intent;
import android.location.Location;
import android.os.Bundle;
import android.os.IBinder;
import android.os.ResultReceiver;
import android.util.Log;

import com.google.android.gms.maps.model.LatLng;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;
import com.google.maps.android.PolyUtil;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;

import test.collegecarpool.alpha.Firebase.PolyLinePusher;
import test.collegecarpool.alpha.PolyDirectionsTools.DirectionParser;
import test.collegecarpool.alpha.PolyDirectionsTools.PolyDirections;
import test.collegecarpool.alpha.PolyDirectionsTools.PolyURLBuilder;
import test.collegecarpool.alpha.Tools.Variables;
import test.collegecarpool.alpha.UserClasses.UserProfile;

public class NavigationService extends Service{

    private final String TAG = "NAVIGATION SERVICE";
    private FirebaseUser user;
    private DatabaseReference userRef;
    ArrayList<LatLng> polyLatLngs;
    ArrayList<LatLng> journeyLatLngs;
    PolyDirections polyDirections;
    ResultReceiver resultReceiver;
    Bundle bundle;
    DirectionParser directionParser;
    boolean journeyFinished;
    boolean routeChanged;
    PolyLinePusher polyLinePusher;
    private String encodePolyLine;
    boolean myPositionAlreadyAdded;

    public NavigationService(){}

    /*Called At the Start of A Service*/
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {

        Log.d(TAG, "NAV SERVICE STARTED");

        /* 3 Have to be Here in Case Service is Restarted, Effectively Renews All Variables (For If Waypoints Are Changed)*/
        myPositionAlreadyAdded = false;
        journeyFinished = false;
        routeChanged = false;

        /*START THE SAT_NAV*/
        Variables.SAT_NAV_ENABLED = true;

        /*Assign the PolyLine LatLngs to latLngs && Journey Waypoints as ArrayList<LatLng> && ResultReceiver*/
        resultReceiver = intent.getParcelableExtra("ResultReceiver");
        polyLatLngs = intent.getParcelableArrayListExtra("PolyLatLngs");
        journeyLatLngs = intent.getParcelableArrayListExtra("JourneyLatLngs");

        /*Listener For Location Changes. If Change, Update the Polyline */
        FirebaseAuth auth = FirebaseAuth.getInstance();
        if(auth != null)
            user = auth.getCurrentUser();
        polyLinePusher = new PolyLinePusher(user);
        userRef = FirebaseDatabase.getInstance().getReference("UserProfile").child(user.getUid());
        userRef.addValueEventListener(new ValueEventListener() {
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {

                Log.d(TAG, "DETECTED LOCATION CHANGE");
                UserProfile userProfile = dataSnapshot.getValue(UserProfile.class);
                LatLng userLatLng = new LatLng(userProfile.getLatitude(), userProfile.getLongitude());

                /*Only Insert Element(MyLocation) at Start of Journey Waypoints Array If Not Already Done*/
                if(!myPositionAlreadyAdded) {
                    journeyLatLngs.add(0, userLatLng);
                    myPositionAlreadyAdded = true;
                    Log.d(TAG, "ADDED MY POSITION TO JOURNEY ARRAY");
                }
                else {
                    journeyLatLngs.set(0, userLatLng);
                    Log.d(TAG, "OVERWROTE MY POSITION IN JOURNEY ARRAY");
                }

                /*Check If User is On List Generated By PolyLine Builder*/
                if(!userOnRoute(userLatLng)){ //User Was Not On The Correct Route
                    Log.d(TAG, "USER NOT ON ROUTE");
                    try {
                        /*If User Isn't on Route, Update PolyLatLngs and Add User Location To The Start*/
                        polyDirections = new PolyDirections();
                        polyLatLngs = polyDirections.execute(new PolyURLBuilder(journeyLatLngs).buildPolyURL()).get();
                        encodePolyLine = PolyUtil.encode(polyLatLngs);
                        polyLinePusher.pushPolyLine(encodePolyLine, journeyLatLngs.subList(1, journeyLatLngs.size()));
                    }
                    catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                    routeChanged = true;
                    //Log.d(TAG, "PolyLatLng Changed Route :" + polyLatLngs.toString());
                    sendBundle();
                }
                else{ //User Was on Correct Route
                    routeChanged = false;
                    Log.d(TAG, "USER ON ROUTE");
                   try {
                        /*If User Is on Route, Update PolyLatLngs and Add User Location To The Start*/
                        polyDirections = new PolyDirections();
                        polyLatLngs = polyDirections.execute(new PolyURLBuilder(journeyLatLngs).buildPolyURL()).get();
                        encodePolyLine = PolyUtil.encode(polyLatLngs);
                        polyLinePusher.pushPolyLine(encodePolyLine, journeyLatLngs.subList(1, journeyLatLngs.size()));
                   }
                   catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                   }
                   Log.d(TAG, "PolyLatLng Changed Route: " + polyLatLngs.toString());

                    /*Direction Parser Contains the JSON String*/
                    directionParser = polyDirections.getDirectionParser();
                    Log.d(TAG, "Parser is " + directionParser.toString());

                    //PERFORM ANY OTHER CALCULATIONS WITH THE JSON HERE

                    /*Check if the User is At A Journey LatLng. If So, Delete It*/
                    if(userAtWaypoint(userLatLng)){
                        Log.d(TAG, "User Is At A Waypoint");
                        removeWaypoint(userLatLng);
                        if(journeyLatLngs.size() < 2 && myPositionAlreadyAdded) {
                            Log.d(TAG, "ALL WAYPOINTS REACHED, SERVICE STOPPED");
                            userRef.removeEventListener(this);
                            Log.d(TAG, "Value Event Listener Removed");
                            stopMyService();
                        }
                        else {
                            Log.d(TAG, "JOURNEY FINISHED IS " + journeyFinished);
                        }
                    }

                    /*Check if the Journey is Over (Only Consists of my Location) - Could Arise Through Deletion Of Waypoints*/
                    if(journeyLatLngs.size() < 2 && myPositionAlreadyAdded) {
                        Log.d(TAG, "ALL WAYPOINTS GONE, SERVICE STOPPED");
                        userRef.removeEventListener(this);
                        Log.d(TAG, "Value Event Listener Removed");
                        stopMyService();
                    }

                    /*Only Want To Call Send Bundle Once Unless Called When Service Stopped*/
                    sendBundle();

                    /*Stops the CallBack That Will Continue Running And Nullifies the Active Journey*/
                    if(!Variables.SAT_NAV_ENABLED){
                        userRef.removeEventListener(this);
                        //polyLinePusher.nullify();
                        Log.d(TAG, "VALUE EVENT LISTENER REMOVED && ACTIVE JOURNEY NULLIFIED");
                    }
                }
            }

            @Override
            public void onCancelled(DatabaseError databaseError) {

            }
        });
        return START_NOT_STICKY; //Run Until It is Specifically Stopped
    }

    /*Check if User is Within 10m of Route*/
    private boolean userOnRoute(LatLng userLatLng){
        return PolyUtil.isLocationOnPath(userLatLng, polyLatLngs, false, 100);
    }

    /*Check If The User Has Reached A Waypoint -- Incorporate Delete For the Waypoint*/
    private boolean userAtWaypoint(LatLng userLatLng){
        Log.d(TAG, "JOURNEYS LIST: " + journeyLatLngs.toString());
        Log.d(TAG, "SUB LIST OF ACTUAL WAYPOINTS: " + journeyLatLngs.subList(1, journeyLatLngs.size()).toString());
        return PolyUtil.isLocationOnPath(userLatLng, journeyLatLngs.subList(1, journeyLatLngs.size()), false, 100);
    }

    /*Find The Point Nearest To The User LatLng*/
    private void removeWaypoint(LatLng userLatLng){
        boolean waypointToBeRemoved = false;
        float [] distance = new float [1];
        double minDistance = 50;
        LatLng temp = new LatLng(0, 0);
        for(LatLng journeyLatLng : journeyLatLngs.subList(1, journeyLatLngs.size())){ //User LatLng at Position 0 in ArrayList
            Location.distanceBetween(userLatLng.latitude, userLatLng.longitude, journeyLatLng.latitude, journeyLatLng.longitude, distance);
            if(distance[0] < minDistance){
                temp = new LatLng(journeyLatLng.latitude, journeyLatLng.longitude);
                waypointToBeRemoved = true;
                Log.d(TAG, userLatLng.toString() + "  ||  " + journeyLatLng);
                Log.d(TAG, "NEW MIN DISTANCE IS " + distance[0]);
                minDistance = distance[0];
            }
            else{
                Log.d(TAG, "OBTAINED DISTANCE IS " + distance[0]);
            }
        }
        if(waypointToBeRemoved) {
            Log.d(TAG, "REMOVED " + temp.toString());
            journeyLatLngs.remove(temp);
            Log.d(TAG, "NEW JOURNEY IS " + journeyLatLngs.toString());
        }
    }

    /*Stop the Journey If userLatLng is the only LatLng Left in the Journey Array*/
    private void stopMyService(){
        Log.d(TAG, "ALL WAYPOINTS REACHED, SERVICE STOPPED");
        Variables.SAT_NAV_ENABLED = false;
        journeyFinished = true;
        if(polyDirections != null) {
            polyDirections.cancel(true);
            polyDirections = null;
            Log.d(TAG, "ASYNC KILLED");
        }
        sendBundle();
        this.stopSelf();
    }

    /*Sends A Bundle Of Extras to the ResultReceiver*/
    private void sendBundle(){
        bundle = new Bundle();
        bundle.putSerializable("PolyLatLngs", polyLatLngs);
        bundle.putSerializable("JourneyLatLngs", journeyLatLngs);
        bundle.putBoolean("JourneyFinished", journeyFinished);
        resultReceiver.send(0, bundle);
        Log.d(TAG, "BUNDLE SENT TO RESULT RECEIVER");
    }

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    /*Called First When The Service Is Started*/
    @Override
    public void onCreate(){
        super.onCreate();
    }


    /*Called When the Service is Stopped*/
    @Override
    public void onDestroy(){
        super.onDestroy();
        if(polyDirections != null) {
            polyDirections.cancel(true);
            polyDirections = null;
            Log.d(TAG, "ASYNC KILLED");
        }
        //polyLinePusher.nullify();
        Log.d(TAG, "SAT_NAV_SERVICE STOPPED");
        Variables.SAT_NAV_ENABLED = false;
        this.stopSelf();
    }
}
