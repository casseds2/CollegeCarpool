package test.collegecarpool.alpha.Services;

import android.app.Service;
import android.content.Intent;
import android.location.Location;
import android.os.Bundle;
import android.os.IBinder;
import android.os.ResultReceiver;
import android.util.Log;

import com.google.android.gms.maps.model.LatLng;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;
import com.google.maps.android.PolyUtil;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;

import test.collegecarpool.alpha.Firebase.PolyLinePusher;
import test.collegecarpool.alpha.MapsUtilities.DirectionStep;
import test.collegecarpool.alpha.PolyDirectionsTools.DirectionParser;
import test.collegecarpool.alpha.PolyDirectionsTools.PolyDirections;
import test.collegecarpool.alpha.PolyDirectionsTools.PolyURLBuilder;
import test.collegecarpool.alpha.Tools.Variables;
import test.collegecarpool.alpha.UserClasses.UserProfile;

public class NavigationService extends Service{

    private final String TAG = "NAVIGATION SERVICE";
    private FirebaseUser user;
    private DatabaseReference userRef;
    ArrayList<LatLng> polyLatLngs;
    ArrayList<LatLng> journeyLatLngs;
    ArrayList<DirectionStep> directionSteps;
    PolyDirections polyDirections;
    ResultReceiver resultReceiver;
    Bundle bundle;
    DirectionParser directionParser;
    boolean journeyFinished;
    boolean routeChanged;
    PolyLinePusher polyLinePusher;
    boolean myPositionAlreadyAdded;
    LatLng userLatLng;

    /*For Direction Step*/
    int duration;
    int distance;
    String instruction;
    String maneuver;
    boolean atStartStep;
    boolean atEndStep;
    DirectionStep currentStep;
    int indexEnd;
    boolean serviceStarted;
    int stepCount;

    public NavigationService(){}

    /*Called At the Start of A Service*/
    @Override
    public int onStartCommand(Intent intent, int flags, final int startId) {

        Log.d(TAG, "NAV SERVICE STARTED");

        /* 3 Have to be Here in Case Service is Restarted, Effectively Renews All Variables (For If Waypoints Are Changed)*/
        myPositionAlreadyAdded = false;
        journeyFinished = false;
        routeChanged = false;

        /*For Direction Step*/
        atStartStep = true;
        atEndStep = false;
        distance = 0;
        instruction = "";
        maneuver = "";
        duration = 0;
        currentStep = new DirectionStep();
        indexEnd = 0;
        serviceStarted = true;
        directionSteps = new ArrayList<>();
        stepCount = 0;


        /*START THE SAT_NAV*/
        Variables.SAT_NAV_ENABLED = true;

        /*Assign the PolyLine LatLngs to latLngs && Journey Waypoints as ArrayList<LatLng> && ResultReceiver*/
        resultReceiver = intent.getParcelableExtra("ResultReceiver");
        polyLatLngs = intent.getParcelableArrayListExtra("PolyLatLngs");
        journeyLatLngs = intent.getParcelableArrayListExtra("JourneyLatLngs");

        /*Listener For Location Changes. If Change, Update the Polyline */
        FirebaseAuth auth = FirebaseAuth.getInstance();
        if(auth != null)
            user = auth.getCurrentUser();
        polyLinePusher = new PolyLinePusher();
        userRef = FirebaseDatabase.getInstance().getReference("UserProfile").child(user.getUid());
        userRef.addValueEventListener(new ValueEventListener() {
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {

                Log.d(TAG, "DETECTED LOCATION CHANGE");
                UserProfile userProfile = dataSnapshot.getValue(UserProfile.class);
                userLatLng = new LatLng(userProfile.getLatitude(), userProfile.getLongitude());

                /*Variables Have To be Restarted At Each Iteration*/
                atStartStep = serviceStarted;
                atEndStep = false;

                /*Only Insert Element(MyLocation) at Start of Journey Waypoints Array If Not Already Done*/
                if (!myPositionAlreadyAdded) {
                    journeyLatLngs.add(0, userLatLng);
                    myPositionAlreadyAdded = true;
                    Log.d(TAG, "ADDED MY POSITION TO JOURNEY ARRAY");
                } else {
                    journeyLatLngs.set(0, userLatLng);
                    Log.d(TAG, "OVERWROTE MY POSITION IN JOURNEY ARRAY");
                }

                /*Check If User is On List Generated By PolyLine Builder*/
                if (!userOnRoute(userLatLng)) {
                    Log.d(TAG, "USER NOT ON ROUTE");
                    handleRouteChange();
                }
                else {
                    routeChanged = false;
                    Log.d(TAG, "USER ON ROUTE");

                    /*Check if the User is At A Journey LatLng. If So, Delete It*/
                    if (userAtWaypoint(userLatLng)) {
                        Log.d(TAG, "User Is At A Waypoint");
                        removeWaypointNear(userLatLng);
                        if (journeyLatLngs.size() < 2 && myPositionAlreadyAdded) {
                            Log.d(TAG, "ALL WAYPOINTS REACHED, SERVICE STOPPED");
                            userRef.removeEventListener(this);
                            Log.d(TAG, "Value Event Listener Removed");
                            stopMyService();
                        } else {
                            Log.d(TAG, "There Are " + (journeyLatLngs.size()-1) + " Stops Left Without User Location");
                        /*Do I Want to Handle A Route Change Here?*/
                            handleRouteChange();
                        }
                    }

                    /*If There Is At Least One Direction Step Left*/
                    if(directionSteps.size() > 0) {
                    /*Handle If the User Is At the Start of a Step*/
                        if (userAtStartLocation(userLatLng, directionSteps.get(stepCount).getStart()) || serviceStarted) {
                            serviceStarted = false; //So directions will be loaded straight away
                            atStartStep = true;
                            Log.d(TAG, "USER IS AT A START STEP");
                            currentStep = directionSteps.get(stepCount);
                            Log.d(TAG, "CURRENT STEP: " + currentStep.toString());
                            duration = currentStep.getDuration();
                            distance = currentStep.getDistance();
                            maneuver = currentStep.getManeuver();
                            instruction = currentStep.getHtmlInstruction();
                        }

                        /*Handle If the User Is At the End of a Step*/
                        if (userAtEndLocation(userLatLng, directionSteps.get(stepCount).getEnd()) && !userAtStartLocation(userLatLng, directionSteps.get(0).getStart())) {
                            atEndStep = true;
                            Log.d(TAG, "USER IS AT AN END STEP");
                            if (directionSteps.size() > 0) {
                                Log.d(TAG, "Directions Steps Was: " + directionSteps.get(stepCount).toString());
                                //directionSteps.remove(stepCount);
                                if (null != directionSteps.get(stepCount)) {
                                    stepCount++;
                                    Log.d(TAG, "Directions Steps Is: " + directionSteps.get(stepCount).toString());
                                }
                                else {
                                    Log.d(TAG, "No Direction Steps Left");
                                }
                            }
                        }
                    }

                    /*Check if the Journey is Over (Only Consists of my Location) - Could Arise Through Deletion Of Waypoints*/
                    if (journeyLatLngs.size() < 2 && myPositionAlreadyAdded) {
                        Log.d(TAG, "ALL WAYPOINTS GONE, SERVICE STOPPED");
                        userRef.removeEventListener(this);
                        Log.d(TAG, "Value Event Listener Removed");
                        stopMyService();
                    }

                    /*Stops the CallBack That Will Continue Running And Nullifies the Active Journey*/
                        if (!Variables.SAT_NAV_ENABLED) {
                            userRef.removeEventListener(this);
                            Log.d(TAG, "VALUE EVENT LISTENER REMOVED && ACTIVE JOURNEY NULLIFIED");
                            stopSelf();
                        }
                    }
                    /*Only Want To Call Send Bundle For UI's Sake*/
                    if(currentStep != null) {
                        updatePolyLatLngs(userLatLng, currentStep.getPolyStep()); //List Of the LatLngs Associated With teh Current Step
                    }
                    sendBundle();
            }

            @Override
            public void onCancelled(DatabaseError databaseError) {

            }
        });
        return START_NOT_STICKY; //Run Until It is Specifically Stopped
    }

    /*Handle New Route And Clean Up Variables*/
    private void handleRouteChange(){
        try {
            /*If User Isn't on Route, Update PolyLatLngs and Add User Location To The Start*/
            polyDirections = new PolyDirections();
            Log.d(TAG, "GOOGLE DIRECTIONS REQUEST");
            polyLatLngs = polyDirections.execute(new PolyURLBuilder(journeyLatLngs).buildPolyURL()).get();
            String encodePolyLine = PolyUtil.encode(polyLatLngs);
            polyLinePusher.pushPolyLine(encodePolyLine, journeyLatLngs.subList(1, journeyLatLngs.size()));
            routeChanged = true;
            directionParser = polyDirections.getDirectionParser();
            directionSteps = directionParser.getDirectionSteps();
            atStartStep = true; //Trigger This So That Directions Will be Set?
        }
        catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }

    /*Sends A Bundle Of Extras to the ResultReceiver*/
    private void sendBundle(){
        bundle = new Bundle();
        bundle.putSerializable("PolyLatLngs", polyLatLngs);
        bundle.putSerializable("JourneyLatLngs", journeyLatLngs);
        bundle.putBoolean("JourneyFinished", journeyFinished);
        bundle.putString("Instruction", instruction);
        bundle.putBoolean("atStartStep", atStartStep);
        bundle.putBoolean("atEndStep", atEndStep);
        bundle.putString("Maneuver", maneuver);
        bundle.putInt("Distance", distance);
        bundle.putInt("Duration", duration);
        resultReceiver.send(0, bundle);
        Log.d(TAG, "BUNDLE SENT TO RESULT RECEIVER");
    }

    /*Removed Parts of the Polyline As We Travel*/
    private void updatePolyLatLngs(LatLng userLatLng, ArrayList<LatLng> stepLatLngs){
        ArrayList<LatLng> temp = new ArrayList<>();
        if(stepLatLngs.size() > 0) {
            for (LatLng latLng : stepLatLngs) {
                if (isNear(userLatLng, latLng, 15)) {
                    temp.add(latLng);
                    Log.d(TAG, "Removed From Step: " + latLng.toString());
                }
            }
            polyLatLngs.removeAll(temp);
        }
    }

    /*Check If One LatLng(User) is Close to Another*/
    private boolean isNear(LatLng userLatLng, LatLng other, int threshold){
        float [] distance = new float [1];
        Location.distanceBetween(userLatLng.latitude, userLatLng.longitude, other.latitude, other.longitude, distance);
        return distance[0] < threshold;
    }

    /*Check If User At the Start Of A Step*/
    private boolean userAtStartLocation(LatLng user, LatLng startStep){
        if(isNear(user, startStep, 30)){
            Log.d(TAG, "User At Start Location");
            atStartStep = true;
            return true;
        }
        return false;
    }

    /*Check If User At the End Of A Step*/
    private boolean userAtEndLocation(LatLng user, LatLng endStep){
        if(isNear(user, endStep, 150)){
            atEndStep = true;
            return true;
        }
        return false;
    }

    /*Check if User is Within 10m of Route*/
    private boolean userOnRoute(LatLng userLatLng){
        return PolyUtil.isLocationOnPath(userLatLng, polyLatLngs, false, 80);
    }

    /*Check If The User Has Reached A Waypoint -- Incorporate Delete For the Waypoint*/
    private boolean userAtWaypoint(LatLng userLatLng){
        Log.d(TAG, "JOURNEYS LIST: " + journeyLatLngs.toString());
        Log.d(TAG, "SUB LIST OF ACTUAL WAYPOINTS: " + journeyLatLngs.subList(1, journeyLatLngs.size()).toString());
        return PolyUtil.isLocationOnPath(userLatLng, journeyLatLngs.subList(1, journeyLatLngs.size()), false, 50);
    }

    /*Find The Point Nearest To The User LatLng*/
    private void removeWaypointNear(LatLng userLatLng){
        boolean waypointToBeRemoved = false;
        float [] distance = new float [1];
        double minDistance = 100;
        LatLng temp = new LatLng(0, 0);
        for(LatLng journeyLatLng : journeyLatLngs.subList(1, journeyLatLngs.size())){ //User LatLng at Position 0 in ArrayList
            Location.distanceBetween(userLatLng.latitude, userLatLng.longitude, journeyLatLng.latitude, journeyLatLng.longitude, distance);
            if(distance[0] < minDistance){
                temp = new LatLng(journeyLatLng.latitude, journeyLatLng.longitude);
                waypointToBeRemoved = true;
                Log.d(TAG, "User Lat/Lng: " + userLatLng.toString() + "  ||  Beside Waypoint: " + journeyLatLng);
                Log.d(TAG, "NEW MIN DISTANCE IS " + distance[0]);
                minDistance = distance[0];
            }
            else{
                Log.d(TAG, "OTHER DISTANCE IS " + distance[0]);
            }
        }
        if(waypointToBeRemoved) {
            Log.d(TAG, "REMOVED " + temp.toString());
            journeyLatLngs.remove(temp);
            Log.d(TAG, "NEW JOURNEY IS " + journeyLatLngs.toString());
        }
    }

    /*Stop the Journey If userLatLng is the only LatLng Left in the Journey Array*/
    private void stopMyService(){
        Log.d(TAG, "ALL WAYPOINTS REACHED, SERVICE STOPPED");
        Variables.SAT_NAV_ENABLED = false;
        journeyFinished = true;
        if(polyDirections != null) {
            polyDirections.cancel(true);
            polyDirections = null;
            Log.d(TAG, "ASYNC KILLED");
        }
        this.stopSelf();
    }

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
    }

    /*Called First When The Service Is Started*/
    @Override
    public void onCreate(){
        super.onCreate();
    }


    /*Called When the Service is Stopped*/
    @Override
    public void onDestroy(){
        super.onDestroy();
        if(polyDirections != null) {
            polyDirections.cancel(true);
            polyDirections = null;
            Log.d(TAG, "ASYNC KILLED");
        }
        if(journeyLatLngs.subList(1, journeyLatLngs.size()).size() > 0)
            polyLinePusher.nullify();
        Log.d(TAG, "SAT_NAV_SERVICE STOPPED");
        Variables.SAT_NAV_ENABLED = false;
        this.stopSelf();
    }
}
