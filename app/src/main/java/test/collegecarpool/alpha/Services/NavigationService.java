package test.collegecarpool.alpha.Services;

import android.app.Service;
import android.content.Intent;
import android.location.Location;
import android.os.Bundle;
import android.os.IBinder;
import android.os.ResultReceiver;
import android.util.Log;

import com.google.android.gms.maps.model.LatLng;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;
import com.google.maps.android.PolyUtil;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;

import test.collegecarpool.alpha.Tools.DirectionParser;
import test.collegecarpool.alpha.Tools.PolyDirections;
import test.collegecarpool.alpha.Tools.PolyURLBuilder;
import test.collegecarpool.alpha.Tools.Variables;
import test.collegecarpool.alpha.UserClasses.UserProfile;

public class NavigationService extends Service{

    private final String TAG = "NAVIGATION SERVICE";
    private FirebaseUser user;
    ArrayList<LatLng> polyLatLngs;
    ArrayList<LatLng> journeyLatLngs;
    PolyDirections polyDirections;
    ResultReceiver resultReceiver;
    Bundle bundle;
    DirectionParser directionParser;
    boolean myPositionAlreadyAdded = false;

    public NavigationService(){}

    /*Called At the Start of A Service*/
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {

        /*START THE SAT_NAV*/
        Variables.SAT_NAV_ENABLED = true;

        /*Assign the PolyLine LatLngs to latLngs && Journey Waypoints as ArrayList<LatLng> && ResultReceiver*/
        resultReceiver = intent.getParcelableExtra("ResultReceiver");
        polyLatLngs = intent.getParcelableArrayListExtra("PolyLatLngs");
        journeyLatLngs = intent.getParcelableArrayListExtra("JourneyLatLngs");

        /*Listener For Location Changes. If Change, Update the Polyline */
        FirebaseAuth auth = FirebaseAuth.getInstance();
        if(auth != null)
            user = auth.getCurrentUser();
        DatabaseReference userRef = FirebaseDatabase.getInstance().getReference("UserProfile").child(user.getUid());
        userRef.addValueEventListener(new ValueEventListener() {
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {
                Log.d(TAG, "DETECTED LOCATION CHANGE");
                UserProfile userProfile = dataSnapshot.getValue(UserProfile.class);
                LatLng userLatLng = new LatLng(userProfile.getLatitude(), userProfile.getLongitude());

                /*Only Insert Element(MyLocation) at Start of Journey Waypoints Array If Not Already Done*/
                if(!myPositionAlreadyAdded) {
                    journeyLatLngs.add(0, userLatLng);
                    myPositionAlreadyAdded = true;
                    Log.d(TAG, "ADDED MY POSITION TO JOURNEY ARRAY");
                }
                else {
                    journeyLatLngs.set(0, userLatLng);
                    Log.d(TAG, "OVERWROTE MY POSITION IN JOURNEY ARRAY");
                }

                /*Check If User is On List Generated By PolyLine Builder*/
                if(!userOnRoute(userLatLng)){ //User Was Not On The Correct Route
                    Log.d(TAG, "USER NOT ON ROUTE");
                    try {
                        /*If User Isn't on Route, Update PolyLatLngs and Add User Location To The Start*/
                        polyDirections = new PolyDirections();
                        polyLatLngs = polyDirections.execute(new PolyURLBuilder(journeyLatLngs).buildPolyURL()).get();
                    }
                    catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                    Log.d(TAG, "PolyLatLng Changed !Route :" + polyLatLngs.toString());
                    sendBundle();
                }
                else{ //User Was on Correct Route
                    Log.d(TAG, "USER ON ROUTE");
                    try {
                        /*If User Is on Route, Update PolyLatLngs and Add User Location To The Start*/
                        polyDirections = new PolyDirections();
                        polyLatLngs = polyDirections.execute(new PolyURLBuilder(journeyLatLngs).buildPolyURL()).get();
                    }
                    catch (InterruptedException | ExecutionException e) {
                        e.printStackTrace();
                    }
                    Log.d(TAG, "PolyLatLng Changed Route: " + polyLatLngs.toString());
                    directionParser = polyDirections.getDirectionParser();
                    Log.d(TAG, "Parser is " + directionParser.toString());
                    //PERFORM ANY OTHER CALCULATIONS WITH THE JSON HERE
                    /*Check if the User is At A Journey LatLng. If So, Delete It*/
                    if(userAtWaypoint(userLatLng)){
                        Log.d(TAG, "User Is At A Waypoint");
                        removeWaypoint(userLatLng);
                    }
                    sendBundle();
                }
            }

            @Override
            public void onCancelled(DatabaseError databaseError) {

            }
        });

        return START_STICKY; //Run Until It is Specifically Stopped
    }

    /*Check if User is Within 10m of Route*/
    private boolean userOnRoute(LatLng userLatLng){
        return PolyUtil.isLocationOnPath(userLatLng, polyLatLngs, false, 150.0);
    }

    /*Check If The User Has Reached A Waypoint -- Incorporate Delete For the Waypoint*/
    private boolean userAtWaypoint(LatLng userLatLng){
        return PolyUtil.isLocationOnPath(userLatLng, journeyLatLngs, false, 20.0);
    }

    /*Find The Point Nearest To The User LatLng*/
    private void removeWaypoint(LatLng userLatLng){
        float [] distance = new float [1];
        double minDistance = 5000;
        LatLng temp = new LatLng(0, 0);
        for(LatLng journeyLatLng : journeyLatLngs){
            Location.distanceBetween(userLatLng.latitude, userLatLng.longitude, journeyLatLng.latitude, journeyLatLng.longitude, distance);
            if(distance[0] < minDistance && journeyLatLngs.indexOf(journeyLatLng) != 0){ //MyCurrent LatLng is considered a waypoint in journeyLatLngs @ index 0
                temp = new LatLng(journeyLatLng.latitude, journeyLatLng.longitude);
                Log.d(TAG, "ACTUALLY AT VALID WAYPOINT " + temp.toString());
                Log.d(TAG, "WAYPOINT LOCATION IS " + journeyLatLng);
                Log.d(TAG, "NEW MIN DISTANCE IS " + distance[0]);
                minDistance = distance[0];
            }
            else{
                //Log.d(TAG, "FALSE ALARM, JUST MY LOCATION " + userLatLng.toString());
                //Log.d(TAG, "WAYPOINT LOCATION IS " + journeyLatLng);
                Log.d(TAG, "OLD MIN DISTANCE IS " + distance[0]);
            }
        }
        Log.d(TAG, "Journeys was " + journeyLatLngs.toString());
        Log.d(TAG, "Removed " + temp.toString());
        journeyLatLngs.remove(temp);
        Log.d(TAG, "Journeys now " + journeyLatLngs.toString());
        if(journeyLatLngs.size() == 1 && myPositionAlreadyAdded){
            stopSelf();
            Log.d(TAG, "ALL WAYPOINTS REACHED, SERVICE STOPPED");
        }
    }

    /*Sends A Bundle Of Extras to the ResultReceiver*/
    private void sendBundle(){
        bundle = new Bundle();
        bundle.putSerializable("PolyLatLngs", polyLatLngs);
        bundle.putSerializable("JourneyLatLngs", journeyLatLngs);
        resultReceiver.send(0, bundle);
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        throw new UnsupportedOperationException("Not yet implemented");
    }

    /*Called First When The Service Is Started*/
    @Override
    public void onCreate(){
        super.onCreate();
    }


    /*Called When the Service is Stopped*/
    @Override
    public void onDestroy(){
        super.onDestroy();
        this.stopSelf();
        Log.d(TAG, "SAT_NAV_SERVICE STOPPED");
        Variables.SAT_NAV_ENABLED = false;
    }
}
